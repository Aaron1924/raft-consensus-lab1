This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-05T08:56:17.752Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
client.py
config.conf
raft_pb2_grpc.py
raft_pb2.py
raft.proto
README.MD
requirements.txt
server.py

================================================================
Repository Files
================================================================

================
File: client.py
================
import grpc
import raft_pb2
import sys

from raft_pb2_grpc import RaftElectionServiceStub as RaftElectionService
from typing import Optional

AppendRequest = raft_pb2.AppendRequest
AppendResponse = raft_pb2.AppendResponse
GetLeaderResponse = raft_pb2.GetLeaderResponse
SuspendRequest = raft_pb2.SuspendRequest
Void = raft_pb2.Void
VoteRequest = raft_pb2.VoteRequest
VoteResponse = raft_pb2.VoteResponse
Key = raft_pb2.Key
KeyValue = raft_pb2.KeyValue
SetValResponse = raft_pb2.SetValResponse
GetValResponse = raft_pb2.GetValResponse


class CommandNotExistError(Exception):
    pass


class NoServerProvidedError(Exception):
    pass


class InternalSerivceError(Exception):
    pass


class UserService:

    def __init__(self):
        self.address: Optional[str] = None
        self.service: Optional[RaftElectionService] = None

    def connect(self, ipaddr: str, port: int) -> None:
        self.address = f"{ipaddr}:{port}"
        channel = grpc.insecure_channel(self.address)
        self.service = RaftElectionService(channel)

    def get_leader(self) -> (int, str):
        self.__validate_server()
        request = Void()
        response: GetLeaderResponse = self.service.GetLeader(request)
        return response.nodeId, response.nodeAddress

    def suspend(self, period_sec: str) -> None:
        period = self.__validate_period(period_sec)
        self.__validate_server()
        request = SuspendRequest(period=period)
        self.service.Suspend(request)

    def set_val(self, key: str, value: str) -> None:
        self.__validate_server()
        request = KeyValue(key=key, value=value)
        response: SetValResponse = self.service.SetVal(request)
        if not response.success:
            raise InternalSerivceError("Procedure call is failed")

    def get_val(self, key: str) -> Optional[str]:
        self.__validate_server()
        request = Key(key=key)
        response: GetValResponse = self.service.GetVal(request)
        return response.value if response.success else None

    def __validate_server(self):
        if not self.service:
            raise NoServerProvidedError("No server address provided")

    @staticmethod
    def __validate_period(period: str) -> int:
        period = int(period)
        if type(period) is not int or 0 < period > 3600:
            raise ValueError("Period must an integer that belongs to range [0, 3600]")
        return period


def main() -> None:
    service = UserService()
    print("The client starts")

    while True:
        try:
            line = input('> ')
            if not line:
                continue

            command, *args = line.split(maxsplit=1)

            if command == "connect":
                service.connect(*args[0].split(maxsplit=1))
                print(f"Connected to {args[0]}")
            elif command == "getleader":
                response = service.get_leader()
                print(*response)
            elif command == "suspend":
                service.suspend(period_sec=args[0])
            elif command == "setval":
                key, value = args[0].split(maxsplit=1)
                service.set_val(key=key, value=value)
            elif command == "getval":
                response = service.get_val(key=args[0])
                print(response)
            elif command == "quit":
                raise KeyboardInterrupt
            else:
                raise CommandNotExistError("Command does not exist")
        except grpc.RpcError:
            print("The server is unavailable")
        except KeyboardInterrupt:
            print("The client ends")
            sys.exit(0)
        except InternalSerivceError:
            pass
        except Exception as e:
            print(e)
            print("Try again!")


if __name__ == "__main__":
    main()

================
File: config.conf
================
0 127.0.0.1 5000
1 127.0.0.1 5001
2 127.0.0.1 5002
3 127.0.0.1 5003
4 127.0.0.1 5004

================
File: raft_pb2_grpc.py
================
# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
import grpc
import warnings

import raft_pb2 as raft__pb2

GRPC_GENERATED_VERSION = '1.68.0'
GRPC_VERSION = grpc.__version__
_version_not_supported = False

try:
    from grpc._utilities import first_version_is_lower
    _version_not_supported = first_version_is_lower(GRPC_VERSION, GRPC_GENERATED_VERSION)
except ImportError:
    _version_not_supported = True

if _version_not_supported:
    raise RuntimeError(
        f'The grpc package installed is at version {GRPC_VERSION},'
        + f' but the generated code in raft_pb2_grpc.py depends on'
        + f' grpcio>={GRPC_GENERATED_VERSION}.'
        + f' Please upgrade your grpc module to grpcio>={GRPC_GENERATED_VERSION}'
        + f' or downgrade your generated code using grpcio-tools<={GRPC_VERSION}.'
    )


class RaftElectionServiceStub(object):
    """Missing associated documentation comment in .proto file."""

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.RequestVote = channel.unary_unary(
                '/RaftElectionService/RequestVote',
                request_serializer=raft__pb2.VoteRequest.SerializeToString,
                response_deserializer=raft__pb2.VoteResponse.FromString,
                _registered_method=True)
        self.AppendEntries = channel.unary_unary(
                '/RaftElectionService/AppendEntries',
                request_serializer=raft__pb2.AppendRequest.SerializeToString,
                response_deserializer=raft__pb2.AppendResponse.FromString,
                _registered_method=True)
        self.GetLeader = channel.unary_unary(
                '/RaftElectionService/GetLeader',
                request_serializer=raft__pb2.Void.SerializeToString,
                response_deserializer=raft__pb2.GetLeaderResponse.FromString,
                _registered_method=True)
        self.Suspend = channel.unary_unary(
                '/RaftElectionService/Suspend',
                request_serializer=raft__pb2.SuspendRequest.SerializeToString,
                response_deserializer=raft__pb2.Void.FromString,
                _registered_method=True)
        self.SetVal = channel.unary_unary(
                '/RaftElectionService/SetVal',
                request_serializer=raft__pb2.KeyValue.SerializeToString,
                response_deserializer=raft__pb2.SetValResponse.FromString,
                _registered_method=True)
        self.GetVal = channel.unary_unary(
                '/RaftElectionService/GetVal',
                request_serializer=raft__pb2.Key.SerializeToString,
                response_deserializer=raft__pb2.GetValResponse.FromString,
                _registered_method=True)


class RaftElectionServiceServicer(object):
    """Missing associated documentation comment in .proto file."""

    def RequestVote(self, request, context):
        """Missing associated documentation comment in .proto file."""
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def AppendEntries(self, request, context):
        """Missing associated documentation comment in .proto file."""
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def GetLeader(self, request, context):
        """Missing associated documentation comment in .proto file."""
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def Suspend(self, request, context):
        """Missing associated documentation comment in .proto file."""
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def SetVal(self, request, context):
        """Missing associated documentation comment in .proto file."""
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def GetVal(self, request, context):
        """Missing associated documentation comment in .proto file."""
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_RaftElectionServiceServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'RequestVote': grpc.unary_unary_rpc_method_handler(
                    servicer.RequestVote,
                    request_deserializer=raft__pb2.VoteRequest.FromString,
                    response_serializer=raft__pb2.VoteResponse.SerializeToString,
            ),
            'AppendEntries': grpc.unary_unary_rpc_method_handler(
                    servicer.AppendEntries,
                    request_deserializer=raft__pb2.AppendRequest.FromString,
                    response_serializer=raft__pb2.AppendResponse.SerializeToString,
            ),
            'GetLeader': grpc.unary_unary_rpc_method_handler(
                    servicer.GetLeader,
                    request_deserializer=raft__pb2.Void.FromString,
                    response_serializer=raft__pb2.GetLeaderResponse.SerializeToString,
            ),
            'Suspend': grpc.unary_unary_rpc_method_handler(
                    servicer.Suspend,
                    request_deserializer=raft__pb2.SuspendRequest.FromString,
                    response_serializer=raft__pb2.Void.SerializeToString,
            ),
            'SetVal': grpc.unary_unary_rpc_method_handler(
                    servicer.SetVal,
                    request_deserializer=raft__pb2.KeyValue.FromString,
                    response_serializer=raft__pb2.SetValResponse.SerializeToString,
            ),
            'GetVal': grpc.unary_unary_rpc_method_handler(
                    servicer.GetVal,
                    request_deserializer=raft__pb2.Key.FromString,
                    response_serializer=raft__pb2.GetValResponse.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'RaftElectionService', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))
    server.add_registered_method_handlers('RaftElectionService', rpc_method_handlers)


 # This class is part of an EXPERIMENTAL API.
class RaftElectionService(object):
    """Missing associated documentation comment in .proto file."""

    @staticmethod
    def RequestVote(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/RaftElectionService/RequestVote',
            raft__pb2.VoteRequest.SerializeToString,
            raft__pb2.VoteResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def AppendEntries(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/RaftElectionService/AppendEntries',
            raft__pb2.AppendRequest.SerializeToString,
            raft__pb2.AppendResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def GetLeader(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/RaftElectionService/GetLeader',
            raft__pb2.Void.SerializeToString,
            raft__pb2.GetLeaderResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def Suspend(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/RaftElectionService/Suspend',
            raft__pb2.SuspendRequest.SerializeToString,
            raft__pb2.Void.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def SetVal(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/RaftElectionService/SetVal',
            raft__pb2.KeyValue.SerializeToString,
            raft__pb2.SetValResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def GetVal(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/RaftElectionService/GetVal',
            raft__pb2.Key.SerializeToString,
            raft__pb2.GetValResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

================
File: raft_pb2.py
================
# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: raft.proto
# Protobuf Python Version: 5.28.1
"""Generated protocol buffer code."""
from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import runtime_version as _runtime_version
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder
_runtime_version.ValidateProtobufRuntimeVersion(
    _runtime_version.Domain.PUBLIC,
    5,
    28,
    1,
    '',
    'raft.proto'
)
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()




DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\nraft.proto\"d\n\x0bVoteRequest\x12\x15\n\rcandidateTerm\x18\x01 \x01(\x04\x12\x13\n\x0b\x63\x61ndidateId\x18\x02 \x01(\x04\x12\x14\n\x0clastLogIndex\x18\x03 \x01(\x04\x12\x13\n\x0blastLogTerm\x18\x04 \x01(\x04\",\n\x0cVoteResponse\x12\x0c\n\x04term\x18\x01 \x01(\x04\x12\x0e\n\x06result\x18\x02 \x01(\x08\"\x97\x01\n\rAppendRequest\x12\x12\n\nleaderTerm\x18\x01 \x01(\x04\x12\x10\n\x08leaderId\x18\x02 \x01(\x04\x12\x14\n\x0cprevLogIndex\x18\x03 \x01(\x04\x12\x13\n\x0bprevLogTerm\x18\x04 \x01(\x04\x12\x1a\n\x07\x65ntries\x18\x05 \x03(\x0b\x32\t.LogEntry\x12\x19\n\x11leaderCommitIndex\x18\x06 \x01(\x04\"<\n\x0e\x41ppendResponse\x12\x0c\n\x04term\x18\x01 \x01(\x04\x12\x0f\n\x07success\x18\x02 \x01(\x08\x12\x0b\n\x03\x61\x63k\x18\x03 \x01(\x04\"\x06\n\x04Void\"8\n\x11GetLeaderResponse\x12\x0e\n\x06nodeId\x18\x01 \x01(\x04\x12\x13\n\x0bnodeAddress\x18\x02 \x01(\t\" \n\x0eSuspendRequest\x12\x0e\n\x06period\x18\x01 \x01(\x04\"\x12\n\x03Key\x12\x0b\n\x03key\x18\x01 \x01(\t\"&\n\x08KeyValue\x12\x0b\n\x03key\x18\x01 \x01(\t\x12\r\n\x05value\x18\x02 \x01(\t\"5\n\x08LogEntry\x12\x1b\n\x08keyValue\x18\x01 \x01(\x0b\x32\t.KeyValue\x12\x0c\n\x04term\x18\x02 \x01(\x04\"!\n\x0eSetValResponse\x12\x0f\n\x07success\x18\x01 \x01(\x08\"0\n\x0eGetValResponse\x12\x0f\n\x07success\x18\x01 \x01(\x08\x12\r\n\x05value\x18\x02 \x01(\t2\x85\x02\n\x13RaftElectionService\x12*\n\x0bRequestVote\x12\x0c.VoteRequest\x1a\r.VoteResponse\x12\x30\n\rAppendEntries\x12\x0e.AppendRequest\x1a\x0f.AppendResponse\x12&\n\tGetLeader\x12\x05.Void\x1a\x12.GetLeaderResponse\x12!\n\x07Suspend\x12\x0f.SuspendRequest\x1a\x05.Void\x12$\n\x06SetVal\x12\t.KeyValue\x1a\x0f.SetValResponse\x12\x1f\n\x06GetVal\x12\x04.Key\x1a\x0f.GetValResponseb\x06proto3')

_globals = globals()
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'raft_pb2', _globals)
if not _descriptor._USE_C_DESCRIPTORS:
  DESCRIPTOR._loaded_options = None
  _globals['_VOTEREQUEST']._serialized_start=14
  _globals['_VOTEREQUEST']._serialized_end=114
  _globals['_VOTERESPONSE']._serialized_start=116
  _globals['_VOTERESPONSE']._serialized_end=160
  _globals['_APPENDREQUEST']._serialized_start=163
  _globals['_APPENDREQUEST']._serialized_end=314
  _globals['_APPENDRESPONSE']._serialized_start=316
  _globals['_APPENDRESPONSE']._serialized_end=376
  _globals['_VOID']._serialized_start=378
  _globals['_VOID']._serialized_end=384
  _globals['_GETLEADERRESPONSE']._serialized_start=386
  _globals['_GETLEADERRESPONSE']._serialized_end=442
  _globals['_SUSPENDREQUEST']._serialized_start=444
  _globals['_SUSPENDREQUEST']._serialized_end=476
  _globals['_KEY']._serialized_start=478
  _globals['_KEY']._serialized_end=496
  _globals['_KEYVALUE']._serialized_start=498
  _globals['_KEYVALUE']._serialized_end=536
  _globals['_LOGENTRY']._serialized_start=538
  _globals['_LOGENTRY']._serialized_end=591
  _globals['_SETVALRESPONSE']._serialized_start=593
  _globals['_SETVALRESPONSE']._serialized_end=626
  _globals['_GETVALRESPONSE']._serialized_start=628
  _globals['_GETVALRESPONSE']._serialized_end=676
  _globals['_RAFTELECTIONSERVICE']._serialized_start=679
  _globals['_RAFTELECTIONSERVICE']._serialized_end=940
# @@protoc_insertion_point(module_scope)

================
File: raft.proto
================
syntax = "proto3";
// python3 -m grpc_tools.protoc raft.proto --proto_path=. --python_out=. --grpc_python_out=.

service RaftElectionService {

  rpc RequestVote(VoteRequest) returns (VoteResponse);

  rpc AppendEntries(AppendRequest) returns (AppendResponse);

  rpc GetLeader(Void) returns (GetLeaderResponse);

  rpc Suspend(SuspendRequest) returns (Void);

  rpc SetVal(KeyValue) returns (SetValResponse);

  rpc GetVal(Key) returns (GetValResponse);
}


message VoteRequest {
  uint64 candidateTerm = 1;
  uint64 candidateId = 2;
  uint64 lastLogIndex = 3;
  uint64 lastLogTerm = 4;
}

message VoteResponse {
  uint64 term = 1;
  bool result = 2;
}

message AppendRequest {
  uint64 leaderTerm = 1;
  uint64 leaderId = 2;
  uint64 prevLogIndex = 3;
  uint64 prevLogTerm = 4;
  repeated LogEntry entries = 5;
  uint64 leaderCommitIndex = 6;
}

message AppendResponse {
  uint64 term = 1;
  bool success = 2;
  uint64 ack = 3;
}

message Void {}

message GetLeaderResponse {
  uint64 nodeId = 1;
  string nodeAddress = 2;
}

message SuspendRequest {
  uint64 period = 1;
}

message Key {
  string key = 1;
}

message KeyValue {
  string key = 1;
  string value = 2;
}

message LogEntry {
  KeyValue keyValue = 1;
  uint64 term = 2;
}

message SetValResponse {
  bool success = 1;
}

message GetValResponse {
  bool success = 1;
  string value = 2;
}

================
File: README.MD
================
#INSTRUCTION

#1. Create a new repository on GitHub and clone it to your computer.

#2. install dependencies
```bash
pip install -r requirements.txt
```

#3. Run the server, every server is a terminal
```bash
py server.py {id}
or
python3 server.py {id}
```

#4. Run the client
```bash
py client.py
or
python3 client.py
```

================
File: requirements.txt
================
grpcio
grpcio-tools
pymongo

================
File: server.py
================
import math
import multiprocessing
import random
import sys
import threading
import time
from concurrent import futures
from typing import Callable, Any
from pymongo import MongoClient
import grpc
import raft_pb2
import raft_pb2_grpc as pb_grpc

# noinspection DuplicatedCode
AppendRequest = raft_pb2.AppendRequest
AppendResponse = raft_pb2.AppendResponse
GetLeaderResponse = raft_pb2.GetLeaderResponse
SuspendRequest = raft_pb2.SuspendRequest
Void = raft_pb2.Void
VoteRequest = raft_pb2.VoteRequest
VoteResponse = raft_pb2.VoteResponse
Key = raft_pb2.Key
KeyValue = raft_pb2.KeyValue
SetValResponse = raft_pb2.SetValResponse
GetValResponse = raft_pb2.GetValResponse
LogEntry = raft_pb2.LogEntry

HEARTBEAT_INTERVAL = 5000 # ms
ELECTION_INTERVAL = 1000, 2000 # ms


def parse_server_config(config: str) -> (int, str):
    params = config.replace('[', '').replace(']', '').split()
    return int(params[0].replace('Node', '')), f"{params[1]}:{params[2]}"

def generate_random_timeout() -> int:
    return random.randint(ELECTION_INTERVAL[0], ELECTION_INTERVAL[1])


def start_after_time(period_sec: float, func: Callable, *args, **kwargs) -> None:
    timer = threading.Timer(period_sec, func, args, kwargs)
    timer.start()


# noinspection PyUnresolvedReferences
class RepeatTimer(threading.Timer):
    """ Taken from https://stackoverflow.com/a/48741004/11825114 """

    def run(self) -> None:
        while not self.finished.wait(self.interval):
            self.function(*self.args, **self.kwargs)


def get_service_stub(node_address: str) -> pb_grpc.RaftElectionServiceStub:
    channel = grpc.insecure_channel(node_address)
    client_stub = pb_grpc.RaftElectionServiceStub(channel)
    return client_stub


class RaftElectionService(pb_grpc.RaftElectionServiceServicer):

    def __init__(self, server_id: int, server_address: str, servers: dict[int, str]) -> None:
        super().__init__()
        
        #MongoBD connection
        database_name = f"raft_node_{self.server_id}_db"
        self.mongo_client = MongoClient("mongodb://localhost:27017/{database_name}")
        self.db = self.mongo_client[database_name]
        self.term_collection = self.db["current terms"]
        self.logs_collection = self.db["logs"]
        print(f"MongoDB connected. DB: {self.db}, Term Collection: {self.term_collection}, Logs Collection: {self.logs_collection}")

        # log receiving
        self.logs: [LogEntry] = []        
        self.commit_length: int = 0
        self.sent_length: dict[str, int] = {}
        self.acked_length: dict[str, int] = {}
        self.data: dict[str, str] = {}

        self.current_term = 0
        self.server_id = server_id
        self.server_address = server_address
        self.servers = servers
        self.election_timeout = generate_random_timeout()
        self.state = None
        self.election_timer = None
        self.current_vote = None
        self.start_following()
        self.leader_id = None
        self.leader_address = None
        self.leader_timer = None
        self.should_interrupt = False

    

        #Load Current Term or set to 0
        term_data = self.term_collection.find_one({"server_id": server_id})
        if term_data:
            self.current_term = term_data["current_term"]
        else:
            self.current_term = 0
            self.term_collection.insert_one({"server_id": server_id, "current_term": self.current_term})


    def start_election_timer(self) -> threading.Timer:
        """ Unit of timeout is ms """
        election_timer = threading.Timer(self.election_timeout / 1000, self.start_election)
        election_timer.start()
        return election_timer

    def start_following(self):
        self.state = "follower"
        print(f"I am a follower. Term: {self.current_term}")

        #Save current term to MongoDB
        self.term_collection.update_one(
            {"server_id": self.server_id},
            {"$set": {"current_term": self.current_term}},
            upsert=True
        )

        self.election_timer = self.start_election_timer()

    def start_election(self):
        print("The leader is dead")
        print(f"I am a candidate. Term: {self.current_term}")
        if self.state != "follower":
            return

        self.state = "candidate"
        self.current_term += 1

        #Save current term to MongoDB
        self.term_collection.update_one(
            {"server_id": self.server_id},
            {"$set": {"current_term": self.current_term}},
            upsert=True
        )
        

        self.current_vote = self.server_id
        print(f"Voted for node {self.server_id}")
        number_of_voted = 1  # because server initially votes for itself

        queue = multiprocessing.Queue()
        threads = []

        last_term = 0
        if len(self.logs) > 0:
            last_term = self.logs[-1].term

        for _, server_address in self.servers.items():
            thread = threading.Thread(target=self.request_election_vote, args=(server_address,
                                                                               queue,
                                                                               last_term,
                                                                               len(self.logs)))
            thread.daemon = True
            threads.append(thread)
            if self.state != "candidate":
                return
            thread.start()

        for thread in threads:
            thread.join()

        print(f"Votes received", end=": ")
        while not queue.empty():
            vote_result = queue.get()
            if vote_result is None:  # if server is not responding
                continue

            if vote_result.term > self.current_term:
                self.current_term = vote_result.term
                self.current_vote = None
                self.start_following()
                return
            if vote_result.result:
                number_of_voted += 1
        print(number_of_voted)
        if number_of_voted > (len(self.servers) + 1) / 2:
            self.start_leading()
        else:
            self.election_timeout = generate_random_timeout()
            self.start_following()

    def request_election_vote(self, address: str, queue, last_term: int, last_index: int) -> None:
        client_stub = get_service_stub(node_address=address)
        # noinspection PyBroadException
        try:
            result: VoteResponse = client_stub.RequestVote(
                VoteRequest(candidateTerm=self.current_term,
                            candidateId=self.server_id,
                            lastLogTerm=last_term,
                            lastLogIndex=last_index))
            queue.put(result)
        except Exception:
            pass

    def start_leading(self):
        print(f"I am a leader. Term: {self.current_term}")
        self.election_timer.cancel()
        self.state = "leader"
        self.leader_id = self.server_id
        self.leader_address = self.server_address

        for _, server_address in self.servers.items():
            self.sent_length[server_address] = len(self.logs)
            self.acked_length[server_address] = 0

        self.leader_timer = RepeatTimer(HEARTBEAT_INTERVAL / 1000, function=self.send_heartbeats)
        self.leader_timer.start()
        while self.state == "leader":
            if self.should_interrupt:
                self.leader_timer.cancel()
                return
        print(f"I am a follower. Term: {self.current_term}")
        self.leader_timer.cancel()

    def send_heartbeats(self):
        threads = []

        for _, server_address in self.servers.items():
            # replicate log
            thread = threading.Thread(target=self.send_heartbeat, args=(server_address,))
            thread.daemon = True
            threads.append(thread)
            thread.start()
            # replicate log end

        for thread in threads:
            if self.should_interrupt:
                return
            thread.join()

    def send_heartbeat(self, server_address):
        client_stub = get_service_stub(server_address)

        if self.sent_length and self.logs:
            # if for current moment there are new logs => send them with heartbeat
            i = self.sent_length[server_address]
            entries: [LogEntry] = self.logs[i:]
            prev_log_term: int = self.logs[i - 1].term if (i > 0) else 0
            # end
        else:
            i = 0
            prev_log_term = 0
            entries = []

        # noinspection PyBroadException
        try:
            result = client_stub.AppendEntries(
                AppendRequest(leaderTerm=self.current_term,
                              leaderId=self.server_id,
                              prevLogIndex=i,
                              prevLogTerm=prev_log_term,
                              entries=entries,
                              leaderCommitIndex=self.commit_length))
            if not result.success:
                self.current_term = result.term
                self.state = "follower"
                return

            # print(f"Heartbeat with append entries was sent to {server_address}")

            self.on_append_response(follower_address=server_address,
                                    term=result.term,
                                    ack=result.ack,
                                    success=result.success)

        except Exception:
            pass

    def __acks(self, length: int):
        acks = 1  # leader acks its changes
        for _, address in self.servers.items():
            if self.acked_length[address] >= length:
                acks += 1
        return acks

    def commit_log_entries(self):
        min_acks = int(math.ceil((len(self.servers) + 1) / 2))
        ready = []
        for length in range(1, len(self.logs) + 1):
            if self.__acks(length) >= min_acks:
                ready.append(length)
        if len(ready) > 0 and max(ready) > self.commit_length and self.logs[max(ready) - 1].term == self.current_term:
            for i in range(self.commit_length, max(ready)):
                key_value = self.logs[i].keyValue
                self.data[key_value.key] = key_value.value
            self.commit_length = max(ready)

    def on_append_response(self, follower_address: str, term: int, ack: int, success: bool):
        if term == self.current_term and self.state == "leader":
            if success:
                self.sent_length[follower_address] = ack
                self.acked_length[follower_address] = ack
                self.commit_log_entries()
            elif self.sent_length[follower_address] > 0:
                self.sent_length[follower_address] = self.sent_length[follower_address] - 1
                self.send_heartbeat(follower_address)
        elif term > self.current_term:
            self.current_term = term
            if self.state != "follower":
                self.start_following()
            self.current_vote = None
#new
    def append_logs(self, log_length: int, leader_commit: int, entries: [LogEntry]) -> None:
        if len(entries) > 0 and len(self.logs) > log_length:
            if self.logs[log_length].term != entries[0].term:
                self.logs = self.logs[:log_length-1]

        if log_length + len(entries) > len(self.logs):
            for i in range(len(self.logs) - log_length, len(entries)):
                self.logs.append(entries[i])

                #Save to MongoDB
                self.logs_collection.insert_one(
                    {"server_id": self.server_id,
                    "term": entries[i].term,
                    "key": entries[i].keyValue.key,
                    "value": entries[i].keyValue.value                    
                    }
                )

        if leader_commit > self.commit_length:
            for i in range(self.commit_length, leader_commit):
                key_value: KeyValue = self.logs[i].keyValue
                self.data[key_value.key] = key_value.value  # deliver
            self.commit_length = leader_commit

    def RequestVote(self, request, context):
        candidate_term = request.candidateTerm
        candidate_id = request.candidateId
        last_log_index = request.lastLogIndex
        last_log_term = request.lastLogTerm

        if not self.logs:
            log_ok = True
        else:
            my_log_term = self.logs[-1].term
            log_ok = (last_log_term > my_log_term) or \
                     (last_log_term == my_log_term and last_log_index >= len(self.logs))

        voted_ok = self.current_vote is None or self.current_vote == candidate_id
        term_ok = candidate_term > self.current_term or (candidate_term == self.current_term and voted_ok)

        if log_ok and term_ok:
            self.current_term = candidate_term
            self.current_vote = candidate_id
            if self.state != "follower":
                self.start_following()
            print(f"Voted for: {candidate_id}")
            return VoteResponse(term=self.current_term, result=True)
        else:
            return VoteResponse(term=self.current_term, result=False)

    def AppendEntries(self, request: AppendRequest, context):
        entries = request.entries
        str_entries = []
        for entry in entries:
            str_entries.append((entry.keyValue.key, entry.keyValue.value))

        leader_id = request.leaderId
        term = request.leaderTerm
        log_length = request.prevLogIndex
        log_term = request.prevLogTerm
        leader_commit = request.leaderCommitIndex
        entries: [LogEntry] = request.entries

        self.leader_id = leader_id
        self.leader_address = self.servers[leader_id]
        try:
            if self.state == "follower":
                self.election_timer.cancel()
                self.election_timer = self.start_election_timer()

            if term > self.current_term:
                self.current_term = term
                self.current_vote = None

            if not self.logs:
                log_ok = True
            else:
                log_ok = len(self.logs) >= log_length
                if log_ok and log_length > 0:
                    log_ok = log_term == self.logs[-1].term

            if term == self.current_term and log_ok:
                self.append_logs(log_length, leader_commit, entries)
                ack = log_length + len(entries)
                return AppendResponse(term=self.current_term, success=True, ack=ack)
            else:
                return AppendResponse(term=self.current_term, success=False, ack=0)
        except grpc.RpcError as e:
            print(str(e))

    def GetLeader(self, request, context):
        print("Command from client: getleader")
        node_id, node_address = None, None

        if self.state == "candidate":
            if not self.current_vote:
                node_id, node_address = self.current_vote, self.servers[self.current_vote]
        else:
            node_id, node_address = self.leader_id, self.leader_address

        print(f"{node_id} {node_address}")
        return GetLeaderResponse(nodeId=node_id, nodeAddress=node_address)

    def SetVal(self, request: KeyValue, context):
        if self.state == "leader":
            log_entry = LogEntry(keyValue=request, term=self.current_term)
            self.logs.append(log_entry)
            self.acked_length[self.server_address] = len(self.logs)
            return SetValResponse(success=True)
        else:
            client_stub = get_service_stub(self.leader_address)
            return client_stub.SetVal(request)

    def GetVal(self, request, context):
        if request.key in self.data:
            value = self.data[request.key]
            return GetValResponse(success=True, value=value)
        else:
            return GetValResponse(success=False)

    def Suspend(self, request, context):
        pass


class SuspendableRaftElectionService(RaftElectionService):

    def __init__(self, server_id: int, server_address: str, servers: dict[int, str]) -> None:
        # Ensure that the RaftElectionService is properly initialized
        self.server_id = server_id  
        self.server_address = server_address
        self.servers = servers
        super().__init__(server_id, server_address, servers)
        self.suspended = False

    def RequestVote(self, request, context):
        return self.__wrap_with_suspend(super().RequestVote, request, context)

    def AppendEntries(self, request: AppendRequest, context):
        return self.__wrap_with_suspend(super().AppendEntries, request, context)

    def GetLeader(self, request, context):
        return self.__wrap_with_suspend(super().GetLeader, request, context)

    def SetVal(self, request, context):
        return self.__wrap_with_suspend(super().SetVal, request, context)

    def GetVal(self, request, context):
        return self.__wrap_with_suspend(super().GetVal, request, context)

    def Suspend(self, request, context):
        return self.__wrap_with_suspend(self.__suspend, request, context)

    # noinspection PyUnusedLocal
    def __suspend(self, request, context) -> Void:
        period = request.period
        print(f"Command from client: suspend {request.period}")

        was_follower = self.state == "follower"

        self.suspended = True

        # actual suspend only after function return
        start_after_time(period_sec=0.025, func=self.__make_suspend, period=period, was_follower=was_follower)

        return Void()

    def __make_suspend(self, period: int, was_follower: bool) -> None:
        self.state = "follower"
        self.election_timer.cancel()
        if self.leader_timer is not None:
            self.leader_timer.cancel()
        print(f"Sleeping for {period} seconds")
        time.sleep(period)

        # after wake up
        if was_follower:
            print(f"I am a follower. Term: {self.current_term}")
        self.election_timer = self.start_election_timer()

        self.suspended = False

    def __wrap_with_suspend(self, func: Callable, request, context) -> Any:
        if self.suspended:
            msg = "Server is suspended"
            context.set_details(msg)
            context.set_code(grpc.StatusCode.UNAVAILABLE)
            return Void()
        else:
            return func(request, context)


def configure_server(server_addr: str, server_id: int, other_servers_addresses: [str]):
    server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))
    server.add_insecure_port(server_addr)
    print(f"The server starts at {server_addr}")
    service = SuspendableRaftElectionService(server_id, server_addr, other_servers_addresses)
    pb_grpc.add_RaftElectionServiceServicer_to_server(
        service,
        server
    )
    return service, server


def start_server() -> None:
    needed_server_id = int(sys.argv[1])
    config_file = open("config.conf", "r")
    servers = {}
    needed_server_address = None
    for server_line in config_file.read().splitlines():
        server_id, address = parse_server_config(server_line)
        if server_id == needed_server_id:
            needed_server_address = address
            continue
        servers[server_id] = address
    config_file.close()

    if needed_server_address is None:
        print("No such available server id")
        sys.exit()

    service, server = configure_server(server_addr=needed_server_address,
                                       server_id=needed_server_id,
                                       other_servers_addresses=servers)

    try:
        server.start()
        server.wait_for_termination()
    except KeyboardInterrupt:
        service.should_interrupt = True
        server.stop(grace=None)
        print("Shutting down")
        sys.exit(0)


if __name__ == "__main__":
    start_server()
